# -*- coding: utf-8 -*-

from odoo.exceptions import UserError, ValidationError
from odoo import api, fields, models, _
import datetime


class ProductProduct(models.Model):
    _inherit = "product.product"

    is_exclude = fields.Boolean(string="Is Excluded Variant",
                                store=True)


class ProductTemplate(models.Model):
    _inherit = "product.template"

    @api.multi
    def get_attr_no_buy(self):
        ids = self.attribute_line_ids.mapped('product_template_value_ids').filtered(
            lambda a: a.product_attribute_value_id.is_not_buy).ids

        return {'no_buys': ids}


class ProductAttributeValue(models.Model):
    _inherit = "product.attribute.value"

    attribute_value_ids = fields.Many2many(
        comodel_name='product.attribute.value',
        relation='sub_attr',
        column1='parent_attr',
        column2='child_attr',
        string="Sub Attribute Values")

    is_not_buy = fields.Boolean(string="Is Not Buyable",
                                help="Check this box to restrict customer from selecting and "
                                     "buying this product with this attribute.")

    def create_ex_attr_val(self, prod, main_attr, tmpl_attr):
        """Function that begins automatic attribute value addition to products based on sub attribute values

        Args:
            self: model self.
            prod: Current product gotten from the current attr_line.
            main_attr: Current main attribute value that is being iterated over.
            tmpl_attr: A dict of attributes+values for product.template.

        Returns:
            None

        """

        # Use of product.template.attribute.value:
        # Materialized relationship between attribute values
        # and product template generated by the product.template.attribute.line

        # product.template.attribute.value on current product.template that
        # ARE attribute(fabric) and NOT current attribute(poly) > should only be cotton
        need_exclusion = self.env['product.template.attribute.value'].search([
            ['product_tmpl_id', '=', prod.id],
            ['attribute_id', '=', main_attr.attribute_id.id],
            ['product_attribute_value_id', '!=', main_attr.id]])
        # product.template.attribute.value on current product.template that
        # ARE of the same attribute as those in the sub attributes.
        possible_exclusion = self.env['product.template.attribute.value'].search([
            ['product_tmpl_id', '=', prod.id],
            ['attribute_id', 'in', list(tmpl_attr.keys())]])

        # product.template.attribute.values which need exclusion
        for need in need_exclusion:
            # product.template.attribute.values that might need to be excluded
            for possible in possible_exclusion:
                # if not sub attributes of the need
                if possible.product_attribute_value_id not in need.product_attribute_value_id.attribute_value_ids:
                    has_tmpl_line = [t for t in need.exclude_for if
                                     t.product_tmpl_id == need.product_tmpl_id]
                    if has_tmpl_line:
                        need.write({
                            'exclude_for': [(1, has_tmpl_line[0].id, {
                                'product_tmpl_id': need.product_tmpl_id.id,
                                'value_ids': [(4, possible.id, 0)]
                            })]
                        })
                    # create exclusion line with current template
                    else:
                        need.write({
                            'exclude_for': [(0, 0, {
                                'product_tmpl_id': need.product_tmpl_id.id,
                                'value_ids': [(4, possible.id, 0)]
                            })]
                        })
                    # Handle reverse exclusion
                    rev_has_tmpl_line = [t for t in possible.exclude_for if
                                         t.product_tmpl_id == possible.product_tmpl_id]
                    if rev_has_tmpl_line:
                        possible.write({
                            'exclude_for': [(1, rev_has_tmpl_line[0].id, {
                                'product_tmpl_id': possible.product_tmpl_id.id,
                                'value_ids': [(4, need.id, 0)]
                            })]
                        })
                    else:
                        possible.write({
                            'exclude_for': [(0, 0, {
                                'product_tmpl_id': possible.product_tmpl_id.id,
                                'value_ids': [(4, need.id, 0)]
                            })]
                        })

    def line_attr_val_add(self, tmpl_attr, prod):
        """Function that begins automatic attribute value addition to products based on sub attribute values

        Args:
            self: model self.
            tmpl_attr: A dict of attributes+values for product.template.
            prod: Current product gotten from the current attr_line.

        Returns:
            None

        """

        # add sub attr val to attr lines IF the line for that attribute exists
        # for attr_id(ex: color) in attributes
        for attr_id in tmpl_attr.keys():
            # check if the line exists on the prod with the current attribute(ex: color)
            exist = [v for v in prod.attribute_line_ids if attr_id == v.attribute_id.id]
            if exist:
                # add the sub attr vals (ex: black, blue) to the existing attr line
                for sub_id in tmpl_attr[attr_id]:
                    exist[0].write({'value_ids': [(4, sub_id, 0)]})
            else:
                # otherwise create a new line with the attr_id(ex: color)
                val = [(4, s, 0) for s in tmpl_attr[attr_id]]
                # then add the sub attr vals (ex: black, blue)
                prod.write({
                    'attribute_line_ids': [(0, 0, {
                        'product_tmpl_id': prod.id,
                        'attribute_id': attr_id,
                        'value_ids': val,
                    })]
                })

    def prod_attr_val_add(self, main_attr, attr_lines, tmpl_attr):
        """Function that begins automatic attribute value addition to products based on sub attribute values

        Args:
            self: model self.
            main_attr: Current main attribute value that is being iterated over.
            attr_lines: All attribute lines with current attribute value(main_attr).
            tmpl_attr: A dict of attributes+values for product.template.

        Returns:
            None

        """
        # prefetching exclusion env for later
        combination_exclude = self.env['product.template.attribute.exclusion']

        # Add the sub attr val to the current attribute value(main_attr)
        # for line all attr lines on the a product template
        for line in attr_lines:
            # line will have unique prod.temp associated (ex: couch)
            prod = line.product_tmpl_id

            # add each of the sub attr val to the product
            self.line_attr_val_add(tmpl_attr, prod)

            # create the variants(prod.prod) for that prod.temp manually
            # using odoo function
            prod.create_variant_ids()

            # create the exclusions on the attribute values
            self.create_ex_attr_val(prod, main_attr, tmpl_attr)

            # Set exclusion boolean on the product variant if attribute values align
            cur_var = prod.product_variant_ids
            for var in cur_var:
                values_ids = var.product_template_attribute_value_ids
                domain = [('product_template_attribute_value_id', 'in', values_ids.ids),
                          ('value_ids', 'in', values_ids.ids), ('product_tmpl_id', '=', prod.id)]
                is_ex = combination_exclude.search(domain)
                if is_ex:
                    var.write({'is_exclude': True})

    def prepare_child_attr_val(self, attr_vals):
        # Loop through all the current attribute values in the recordset
        for attr in attr_vals:
            attr_vals = self.prepare_child_attr_val_recursive(attr, attr_vals)
        return attr_vals

    def prepare_child_attr_val_recursive(self, cur_attr, attr_vals):
        # Create a stop endpoint
        if cur_attr.attribute_value_ids:
            for attr in cur_attr.attribute_value_ids.filtered(lambda a: a not in attr_vals and a.attribute_value_ids):
                attr_vals |= attr
                return self.prepare_child_attr_val_recursive(attr, attr_vals)
        return attr_vals

    @api.model
    def create_attr_val_exclusions(self):
        """Function that begins automatic attribute value addition to products based on sub attribute values

        Args:
            self: model self.

        Returns:
            None

        """

        # Grab all attribute values that has been modified in the last day and had sub att val
        attr_vals = self.env['product.attribute.value'].search([('attribute_value_ids', '!=', False),
                                                                ('write_date', '>', (datetime.datetime.now() -
                                                                                     datetime.timedelta(
                                                                                         days=1)).strftime(
                                                                    '%Y-%m-%d %H:%M:%S'))])
        print("Recently mod attr vals: " + str(attr_vals))

        attr_vals = self.prepare_child_attr_val(attr_vals)

        print("All Child mod attr vals: " + str(attr_vals))

        for main_attr in attr_vals:
            tmpl_attr = {}
            # create a dict of attributes+values for product.template
            # ex: {color.id: [blue.id, black.id]}
            for sub_attr in main_attr.attribute_value_ids:
                tmpl_attr.setdefault(sub_attr.attribute_id.id, []).append(sub_attr.id)
            print("main attr: " + str(main_attr.name_get()))
            print("attr dict: " + str(tmpl_attr))

            # All attribute lines with current attribute value(main_attr)
            # lines are on product.template to generate product.template.attribute.value
            attr_lines = self.env['product.template.attribute.line'].search([['value_ids', 'in', main_attr.id]])

            # Call function to do the value addition/exclusions
            self.prod_attr_val_add(main_attr, attr_lines, tmpl_attr)
