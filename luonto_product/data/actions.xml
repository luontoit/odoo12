<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data>
        <record id="action_update_prod_attr_val" model="ir.actions.server">
            <field name="name">Update Product Attributes</field>
            <field name="type">ir.actions.server</field>
            <field name="model_id" ref="product.model_product_attribute_value"/>
            <field name="binding_model_id" ref="product.model_product_attribute_value"/>
            <field name="state">code</field>
            <field name="code">
# All attribute value selected(ex:cotton)
# Filtered by if it has attribute_value_ids(sub attr)
for main_attr in records.filtered(lambda a: a.attribute_value_ids):
    tmpl_attr = {}
    # create a dict of attributes+values for product.template
    # ex: {color.id: [blue.id, black.id]}
    for sub_attr in main_attr.attribute_value_ids:
        tmpl_attr.setdefault(sub_attr.attribute_id.id, []).append(sub_attr.id)

    # All attribute lines with current attribute value(main_attr)
    # lines are on product.template to generate product.template.attribute.value
    attr_lines = env['product.template.attribute.line'].search([['value_ids', 'in', main_attr.id]])
    # prefetching exclusion env for later
    combination_exclude = env['product.template.attribute.exclusion']

    # Add the sub attr val to the current attribute value(main_attr)
    # for line all attr lines on the a product template
    for line in attr_lines:
        # line will have unique prod.temp associated (ex: couch)
        prod = line.product_tmpl_id
        # add sub attr val to attr lines IF the line for that attribute exists
        # for attr_id(ex: color) in attributes
        for attr_id in tmpl_attr.keys():
            # check if the line exists on the prod with the current attribute(ex: color)
            exist = [v for v in prod.attribute_line_ids if attr_id == v.attribute_id.id]
            if exist:
                # add the sub attr vals (ex: black, blue) to the existing attr line
                for sub_id in tmpl_attr[attr_id]:
                    exist[0].write({'value_ids': [(4, sub_id, 0)]})
            else:
                # otherwise create a new line with the attr_id(ex: color)
                val = [(4, s, 0) for s in tmpl_attr[attr_id]]
                # then add the sub attr vals (ex: black, blue)
                prod.write({
                    'attribute_line_ids': [(0, 0, {
                        'product_tmpl_id': prod.id,
                        'attribute_id': attr_id,
                        'value_ids': val,
                    })]
                })
        # create the variants(prod.prod) for that prod.temp manually
        prod.create_variant_ids()

        # Use of product.template.attribute.value:
        # Materialized relationship between attribute values
        # and product template generated by the product.template.attribute.line

        # product.template.attribute.value on current product.template that
        # ARE attribute(fabric) and NOT current attribute(poly) > should only be cotton
        need_exclusion = env['product.template.attribute.value'].search([
            ['product_tmpl_id', '=', prod.id],
            ['attribute_id', '=', main_attr.attribute_id.id],
            ['product_attribute_value_id', '!=', main_attr.id]])
        # product.template.attribute.value on current product.template that
        # ARE of the same attribute as those in the sub attributes.
        possible_exclusion = env['product.template.attribute.value'].search([
            ['product_tmpl_id', '=', prod.id],
            ['attribute_id', 'in', list(tmpl_attr.keys())]])

        # product.template.attribute.values which need exclusion
        for need in need_exclusion:
            # product.template.attribute.values that might need to be excluded
            for possible in possible_exclusion:
                # if not sub attributes of the need
                if possible.product_attribute_value_id not in need.product_attribute_value_id.attribute_value_ids:
                    has_tmpl_line = [t for t in need.exclude_for if
                                     t.product_tmpl_id == need.product_tmpl_id]
                    if has_tmpl_line:
                        need.write({
                            'exclude_for': [(1, has_tmpl_line[0].id, {
                                'product_tmpl_id': need.product_tmpl_id.id,
                                'value_ids': [(4, possible.id, 0)]
                            })]
                        })
                    # create exclusion line with current template
                    else:
                        need.write({
                            'exclude_for': [(0, 0, {
                                'product_tmpl_id': need.product_tmpl_id.id,
                                'value_ids': [(4, possible.id, 0)]
                            })]
                        })
                    # Handle reverse exclusion
                    rev_has_tmpl_line = [t for t in possible.exclude_for if
                                         t.product_tmpl_id == possible.product_tmpl_id]
                    if rev_has_tmpl_line:
                        possible.write({
                            'exclude_for': [(1, rev_has_tmpl_line[0].id, {
                                'product_tmpl_id': possible.product_tmpl_id.id,
                                'value_ids': [(4, need.id, 0)]
                            })]
                        })
                    else:
                        possible.write({
                            'exclude_for': [(0, 0, {
                                'product_tmpl_id': possible.product_tmpl_id.id,
                                'value_ids': [(4, need.id, 0)]
                            })]
                        })
        # Set exclusion boolean on the product variant if attribute values align
        cur_var = prod.product_variant_ids
        for var in cur_var:
            values_ids = var.product_template_attribute_value_ids
            domain = [('product_template_attribute_value_id', 'in', values_ids.ids),
                      ('value_ids', 'in', values_ids.ids), ('product_tmpl_id', '=', prod.id)]
            is_ex = combination_exclude.search(domain)
            if is_ex:
                var.write({'is_exclude': True})
            </field>
        </record>

        <record id="automated_action_update_is_exclusion_luonto" model="ir.cron">
            <field name="name">Product: Update Exclusion Boolean</field>
            <field name="model_id" ref="product.model_product_product"/>
            <field name="state">code</field>
            <field name="code">combination_exclude = env['product.template.attribute.exclusion']
for record in env['product.product'].search([]):
  tmpl_id = record.product_tmpl_id
  values_ids = record.product_template_attribute_value_ids
  domain = [('product_template_attribute_value_id', 'in', values_ids.ids), ('value_ids', 'in', values_ids.ids), ('product_tmpl_id', '=', tmpl_id.id)]
  is_ex = combination_exclude.search(domain)
  if is_ex:
    record['is_exclude'] = True
  else:
    record['is_exclude'] = False
            </field>
            <field name="interval_number">2</field>
            <field name="interval_type">weeks</field>
            <field name="numbercall">-1</field>
            <field name="nextcall" eval="(DateTime.now() + timedelta(days=14)).strftime('%Y-%m-%d 2:00:00')" />
            <field name="doall" eval="False"/>
        </record>


        <record id="schedule_action_update_attributes_luonto" model="ir.cron">
            <field name="name">Attribute: Update Attribute Values via Sub Attribute Values</field>
            <field name="model_id" ref="product.model_product_attribute_value"/>
            <field name="state">code</field>
            <field name="code"># Filter out only Attriute Values that have sub attribute vals AND were modified between the last time this scheduled action was run(hard coded)
attr_vals = env['product.attribute.value'].search([('attribute_value_ids', '!=', False),
                                                   ('write_date', '>', (datetime.datetime.now()-datetime.timedelta(days=1)).strftime('%Y-%m-%d %H:%M:%S'))])
# All attribute value selected(ex:cotton)
# Filtered by if it has attribute_value_ids(sub attr)
for main_attr in attr_vals:
    # log(str(datetime.datetime.now()-datetime.timedelta(days=1))+(str(datetime.datetime.now())), level='info')
    # log(str(main_attr.write_date)+ str(main_attr.name_get()), level='info')
    tmpl_attr = {}
    # create a dict of attributes+values for product.template
    # ex: {color.id: [blue.id, black.id]}
    for sub_attr in main_attr.attribute_value_ids:
        tmpl_attr.setdefault(sub_attr.attribute_id.id, []).append(sub_attr.id)

    # All attribute lines with current attribute value(main_attr)
    # lines are on product.template to generate product.template.attribute.value
    attr_lines = env['product.template.attribute.line'].search([['value_ids', 'in', main_attr.id]])
    # prefetching exclusion env for later
    combination_exclude = env['product.template.attribute.exclusion']

    # Add the sub attr val to the current attribute value(main_attr)
    # for line all attr lines on the a product template
    for line in attr_lines:
        # line will have unique prod.temp associated (ex: couch)
        prod = line.product_tmpl_id
        # add sub attr val to attr lines IF the line for that attribute exists
        # for attr_id(ex: color) in attributes
        for attr_id in tmpl_attr.keys():
            # check if the line exists on the prod with the current attribute(ex: color)
            exist = [v for v in prod.attribute_line_ids if attr_id == v.attribute_id.id]
            if exist:
                # add the sub attr vals (ex: black, blue) to the existing attr line
                for sub_id in tmpl_attr[attr_id]:
                    exist[0].write({'value_ids': [(4, sub_id, 0)]})
            else:
                # otherwise create a new line with the attr_id(ex: color)
                val = [(4, s, 0) for s in tmpl_attr[attr_id]]
                # then add the sub attr vals (ex: black, blue)
                prod.write({
                    'attribute_line_ids': [(0, 0, {
                        'product_tmpl_id': prod.id,
                        'attribute_id': attr_id,
                        'value_ids': val,
                    })]
                })
        # create the variants(prod.prod) for that prod.temp manually
        prod.create_variant_ids()

        # Use of product.template.attribute.value:
        # Materialized relationship between attribute values
        # and product template generated by the product.template.attribute.line

        # product.template.attribute.value on current product.template that
        # ARE attribute(fabric) and NOT current attribute(poly) > should only be cotton
        need_exclusion = env['product.template.attribute.value'].search([
            ['product_tmpl_id', '=', prod.id],
            ['attribute_id', '=', main_attr.attribute_id.id],
            ['product_attribute_value_id', '!=', main_attr.id]])
        # product.template.attribute.value on current product.template that
        # ARE of the same attribute as those in the sub attributes.
        possible_exclusion = env['product.template.attribute.value'].search([
            ['product_tmpl_id', '=', prod.id],
            ['attribute_id', 'in', list(tmpl_attr.keys())]])

        # product.template.attribute.values which need exclusion
        for need in need_exclusion:
            # product.template.attribute.values that might need to be excluded
            for possible in possible_exclusion:
                # if not sub attributes of the need
                if possible.product_attribute_value_id not in need.product_attribute_value_id.attribute_value_ids:
                    has_tmpl_line = [t for t in need.exclude_for if
                                     t.product_tmpl_id == need.product_tmpl_id]
                    if has_tmpl_line:
                        need.write({
                            'exclude_for': [(1, has_tmpl_line[0].id, {
                                'product_tmpl_id': need.product_tmpl_id.id,
                                'value_ids': [(4, possible.id, 0)]
                            })]
                        })
                    # create exclusion line with current template
                    else:
                        need.write({
                            'exclude_for': [(0, 0, {
                                'product_tmpl_id': need.product_tmpl_id.id,
                                'value_ids': [(4, possible.id, 0)]
                            })]
                        })
                    # Handle reverse exclusion
                    rev_has_tmpl_line = [t for t in possible.exclude_for if
                                         t.product_tmpl_id == possible.product_tmpl_id]
                    if rev_has_tmpl_line:
                        possible.write({
                            'exclude_for': [(1, rev_has_tmpl_line[0].id, {
                                'product_tmpl_id': possible.product_tmpl_id.id,
                                'value_ids': [(4, need.id, 0)]
                            })]
                        })
                    else:
                        possible.write({
                            'exclude_for': [(0, 0, {
                                'product_tmpl_id': possible.product_tmpl_id.id,
                                'value_ids': [(4, need.id, 0)]
                            })]
                        })
        # Set exclusion boolean on the product variant if attribute values align
        cur_var = prod.product_variant_ids
        for var in cur_var:
            values_ids = var.product_template_attribute_value_ids
            domain = [('product_template_attribute_value_id', 'in', values_ids.ids),
                      ('value_ids', 'in', values_ids.ids), ('product_tmpl_id', '=', prod.id)]
            is_ex = combination_exclude.search(domain)
            if is_ex:
                var.write({'is_exclude': True})
            </field>
            <field name="interval_number">1</field>
            <field name="interval_type">days</field>
            <field name="numbercall">-1</field>
            <field name="nextcall" eval="(DateTime.now() + timedelta(days=1)).strftime('%Y-%m-%d 2:00:00')" />
            <field name="doall" eval="False"/>
        </record>
    </data>
</odoo>